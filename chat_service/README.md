## Description
해당 문제는 client와 server 둘 다 취약점이 존재한다. 둘 다 BOF가 발생하고 있다. 해당 문제의 진짜 플래그는 server의 권한으로 쉘을 따면 얻을 수 있다. 대회때는 client의 쉘만 따고 server의 취약점이 race condition일 거라는 생각에 휩쓸려 취약점을 발견하지 못해 대회 후 다시 풀어보게 되었다.

## Exploit - Client
채팅방에 입장하면 client 하나 당 쓰레드 2개가 돌아가게 된다. 한쪽은 입력을 받고 서버쪽에 채팅 내용을 보내주는 역하을 하고, 다른 한쪽은 서버에서 상대방의 채팅내용을 받고 이를 콘솔에 보여준다. 취약점은 서버에서 채팅을 받는 쪽에서 발생하는데, buf에 최대 0x400까지 읽으면서 buf의 크기는 0x100정도밖에 되지 않는다. 단순 BOF로 ROP를 짜서 쉘을 따면 된다.

## Exploit - Server
두 개의 client가 채팅방에 입장하게 되면 총 3개의 쓰레드가 돌아가게된다. 먼저 생성되는 쓰레드는 나머지 2개의 쓰레드를 생성한 뒤 루프를 돌며 0x6d6960 메모리에 있는 내용을 전해주어야할 client에게 전송해준다.

나머지 두개의 쓰레드는 같은 일을 하는데 client에게 채팅을 받고 이를 0x6d6960 메모리에 올려준다. 물론, 채팅의 길이와 어떤 클라이언트의 채팅인지도 세팅해준다.

여기서 취약점은 부모 쓰레드에서 발생하는데 자식 쓰레드들은 0x800까지의 채팅을 받아서 메모리에 올려준다. 하지만 부모쓰레드가 준비한 버퍼의 크기는 0x400으로 BOF가 발생한다.

이제 이 취약점을 통해 어떻게 공격할건지 생각해봐야하는데 총 2가지 방법을 떠올려볼 수 있다.
- client 취약점을 이용하여 쉘을 딴뒤 server를 공격하는 static binary를 서버에 올린뒤 실행한다.
- 채팅방을 만들고, 입장할때 server와 client가 주고 받는 데이터의 최대크기 차이를 이용

### 1. 직접 binary 실행시키기
첫번째 방법은 괜히 클라이언트의 취약점을 준게 아니라는 생각에 떠올렸다. 특히, 쉘을 따고 들어가보면 start.sh가 있는데 이 곳을 보면 tmp 디렉토리에 733권한을 설정해주고 있다. 일부러 여기에 바이너리를 올리라는 의미로 해석해볼 수도 있다고 생각했다.

정상적인 client 루틴대로라면 채팅의 크기를 0x800으로 설정해서 보내주는 것이 불가능하기 때문에 직접 0x800이라는 사이즈로 설정해서 보내주는 것이다.
(아직 해당 방법으로 익스를 진행해보지 않음. TBC)

### 2. 주어진 client를 이용
채팅방을 만들거나 입장할때의 루틴을 보면 client에서는 0xff만큼의 이름을 받고 앞에 1 혹은 2를 붙여 총 0x100바이트를 전송한다. 하지만 server에서는 최대 0xff만 읽기 때문에 나머지 한 바이트가 다른 루틴의 입력으로 밀리게 되고 다음 루틴의 첫 4바이트는 채팅의 크기를 표현하고 있기 때문에 사이즈를 조작할 수 있다.

이 부분을 이용하여 BOF를 발생시킬 수 있고, 우리의 입력은 고정된 메모리에 올라가므로 이 곳에 shellcode를 올린 뒤 mprotect함수를 이용하여 실행권한을 주고 jmp를 뛰면 된다.

이때 주의할 점은 클라이언트에서 입력할 때 최대 0x400를 읽고 앞에 size 4바이트를 붙여주므로 dummy의 크기를 계산할 때 주의해야한다.
